      expect(result).toBe(true);

      dateSpy.mockRestore();
      cache.get = originalGet;
      cache.set = originalSet;
    });
  });

  describe("releaseLock", () => {
      test("should release lock held by current instance", async () => {
          const originalGet = cache.get;
          const originalDelete = cache.delete;
          
          const getSpy = jest.fn().mockResolvedValue({
              instanceId: "test_instance_123",
              acquiredAt: Date.now(),
              ttl: 300,
          });
          const deleteSpy = jest.fn().mockResolvedValue(true);
          cache.get = getSpy;
          cache.delete = deleteSpy;

          await instanceCoordinator.releaseLock("test_lock");

          expect(deleteSpy).toHaveBeenCalledWith("lock:test_lock");

          cache.get = originalGet;
          cache.delete = originalDelete;
      });

      test("should not release lock held by another instance", async () => {
          // Mock cache.get to return a lock held by another instance
          const originalGet = cache.get;
          const getSpy = jest.fn().mockResolvedValue({
              instanceId: "other_instance",
              acquiredAt: Date.now(),
              ttl: 300
          });
          cache.get = getSpy;

          await instanceCoordinator.releaseLock("test_lock");

          // Should not call delete since it's not our lock
          // The method will call cache.get but not cache.delete
          expect(getSpy).toHaveBeenCalledWith("lock:test_lock", "json", expect.any(Object));

          cache.get = originalGet;
      });
  });

  describe("acquireTaskLock", () => {
    test("should acquire task lock successfully", async () => {
      // Mock acquireLock to return true
      const acquireLockSpy = jest.spyOn(instanceCoordinator, 'acquireLock').mockImplementation(() => Promise.resolve(true));

      const result = await instanceCoordinator.acquireTaskLock("task_123");
      expect(result).toBe(true);
      expect(acquireLockSpy).toHaveBeenCalledWith("task:task_123", 600);

      acquireLockSpy.mockRestore();
    });
  });

  describe("releaseTaskLock", () => {
    test("should release task lock successfully", async () => {
      const releaseLockSpy = jest.spyOn(instanceCoordinator, 'releaseLock');

      await instanceCoordinator.releaseTaskLock("task_123");
      expect(releaseLockSpy).toHaveBeenCalledWith("task:task_123");

      releaseLockSpy.mockRestore();
    });
  });

  describe("acquireTaskLock and releaseTaskLock", () => {
    test("should acquire and release task lock successfully", async () => {
      // Mock acquireLock to return true
      const acquireLockSpy = jest.spyOn(instanceCoordinator, 'acquireLock').mockImplementation(() => Promise.resolve(true));
      const releaseLockSpy = jest.spyOn(instanceCoordinator, 'releaseLock');

      const result = await instanceCoordinator.acquireTaskLock("task_123");
      expect(result).toBe(true);
      expect(acquireLockSpy).toHaveBeenCalledWith("task:task_123", 600);

      await instanceCoordinator.releaseTaskLock("task_123");
      expect(releaseLockSpy).toHaveBeenCalledWith("task:task_123");

      acquireLockSpy.mockRestore();
      releaseLockSpy.mockRestore();
    });
  });

  describe("broadcast", () => {
    test("should broadcast system event with sourceInstance and timestamp", async () => {
      const expectedTime = 1234567890;
      const dateSpy = jest.spyOn(Date, 'now').mockReturnValue(expectedTime);
      const { qstashService } = await import("../../src/services/QStashService.js");
      const broadcastSpy = jest.spyOn(qstashService, "broadcastSystemEvent").mockResolvedValue(undefined);

      await instanceCoordinator.broadcast("instance_started", { nodeType: "dispatcher" });
