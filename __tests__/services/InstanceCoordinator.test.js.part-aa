import { jest, describe, test, expect, beforeEach, beforeAll, afterAll, afterEach } from "@jest/globals";

// Mock the global fetch function
const mockFetch = jest.fn();
global.fetch = mockFetch;

// Store original process.env
const originalEnv = process.env;

let instanceCoordinator;
let cache;
// 【关键】用来存储所有产生的定时器 ID
let capturedIntervals = [];

// Mock InstanceRepository
jest.unstable_mockModule("../../src/repositories/InstanceRepository.js", () => ({
  InstanceRepository: {
    createTableIfNotExists: jest.fn().mockResolvedValue(undefined),
    findAll: jest.fn().mockResolvedValue([]),
    upsert: jest.fn().mockResolvedValue(true),
    updateHeartbeat: jest.fn().mockResolvedValue(true),
  },
}));



// Mock logger
const mockLogger = {
  info: jest.fn(),
  error: jest.fn(),
  warn: jest.fn(),
  debug: jest.fn(),
};

jest.unstable_mockModule("../../src/services/logger.js", () => ({
   default: mockLogger,
   logger: mockLogger,
   setInstanceIdProvider: jest.fn(),
}));

// Mock CacheService to avoid real provider initialization
const mockCache = {
  initialize: jest.fn().mockResolvedValue(undefined),
  get: jest.fn(),
  set: jest.fn(),
  delete: jest.fn(),
  listKeys: jest.fn(),
  getCurrentProvider: jest.fn().mockReturnValue("cloudflare"),
  _startHeartbeat: jest.fn(),
};

jest.unstable_mockModule("../../src/services/CacheService.js", () => ({
  cache: mockCache,
}));

describe("InstanceCoordinator", () => {
  beforeAll(async () => {
    // 【关键修复 1】强制使用真实定时器，防止 async/await 逻辑因为 FakeTimers 导致死锁
    jest.useRealTimers();

    // 【关键修复 2】拦截 setInterval，捕获 ID，但不阻止它运行
    const originalSetInterval = global.setInterval;
    jest.spyOn(global, 'setInterval').mockImplementation((fn, ms) => {
        const id = originalSetInterval(fn, ms);
        capturedIntervals.push(id);
        return id;
    });

    // Set up mock environment variables
    process.env = {
      ...originalEnv,
      CF_CACHE_ACCOUNT_ID: "mock_account_id",
      CF_CACHE_NAMESPACE_ID: "mock_namespace_id",
      CF_CACHE_TOKEN: "mock_kv_token",
      INSTANCE_ID: "test_instance_123",
      CACHE_PROVIDER: undefined,
    };
    jest.resetModules();

    // Dynamically import after setting up mocks
    const { instanceCoordinator: importedIC } = await import("../../src/services/InstanceCoordinator.js");
    instanceCoordinator = importedIC;

    // Also import cache for mocking
    const { cache: importedCache } = await import("../../src/services/CacheService.js");
    cache = importedCache;

    // Pre-initialize cache to avoid repeated async initialization overhead
    await cache.initialize();
  });

  afterAll(() => {
    // 【关键修复 3】测试结束后，暴力清理所有捕获到的定时器
    // 这解决了 "Open Handle" 导致的超时/无法退出问题
    capturedIntervals.forEach(id => clearInterval(id));

    process.env = originalEnv;
    jest.restoreAllMocks();
  });

