  beforeEach(async () => {
    jest.clearAllMocks();
    // Reset instance state
    if (instanceCoordinator) {
        instanceCoordinator.instanceId = "test_instance_123";
        instanceCoordinator.isLeader = false;
        instanceCoordinator.activeInstances = new Set();
    }

    // Ensure Cache provider name is stable for tests
    const { cache } = await import("../../src/services/CacheService.js");
    if (cache?.getCurrentProvider?.mockReturnValue) {
        cache.getCurrentProvider.mockReturnValue("cloudflare");
    }
  });

  afterEach(() => {
    // Clear any timers
    jest.clearAllTimers();
  });

  test("should initialize with correct instance ID", () => {
    expect(instanceCoordinator.instanceId).toBe("test_instance_123");
    expect(instanceCoordinator.heartbeatInterval).toBe(30000); // 30 seconds
    expect(instanceCoordinator.instanceTimeout).toBe(90000); // 90 seconds
  });

  describe("registerInstance", () => {
      test("should register instance successfully (Cache only)", async () => {
          const setSpy = jest.fn().mockResolvedValue(true);
          cache.set = setSpy;
  
          await instanceCoordinator.registerInstance();
  
          // Verify cache write with instance payload
          expect(setSpy).toHaveBeenCalledWith(
            "instance:test_instance_123",
            expect.objectContaining({
              id: "test_instance_123",
              status: "active"
            }),
            expect.any(Number)
          );
      });

      test("should throw error when Cache registration fails", async () => {
          const setSpy = jest.fn().mockRejectedValue(new Error("Cache registration failed"));
          cache.set = setSpy;
  
          // Should throw since Cache is the primary storage
          try {
              await instanceCoordinator.registerInstance();
              // If we get here, the test should fail
              expect(true).toBe(false);
          } catch (error) {
              // The error message may vary depending on the cache provider
              // Just verify that an error was thrown
              expect(error).toBeDefined();
          }
      });
  });

  describe("unregisterInstance", () => {
      test("should unregister instance successfully", async () => {
          // Mock cache.delete to return true
          const originalDelete = cache.delete;
          const deleteSpy = jest.fn().mockResolvedValue(true);
          cache.delete = deleteSpy;

          await instanceCoordinator.unregisterInstance();

          // Verify cache.delete was called with correct key
          expect(deleteSpy).toHaveBeenCalledWith("instance:test_instance_123");

          cache.delete = originalDelete;
      });

      test("should handle unregister instance failure gracefully", async () => {
          // Mock cache.delete to throw error
          const originalDelete = cache.delete;
          const deleteSpy = jest.fn().mockRejectedValue(new Error('Cache Delete Error'));
          cache.delete = deleteSpy;

          // Should not throw, just log error
          await expect(instanceCoordinator.unregisterInstance()).resolves.not.toThrow();

          expect(deleteSpy).toHaveBeenCalledWith("instance:test_instance_123");

          cache.delete = originalDelete;
      });
  });

  describe("acquireLock", () => {
    test("should acquire lock when no existing lock", async () => {
      const expectedTime = 1234567890;
      const dateSpy = jest.spyOn(Date, 'now').mockReturnValue(expectedTime);
      
      const originalGet = cache.get;
      const originalSet = cache.set;
      
