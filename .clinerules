# 代码修改原则

1. 生产质量第一：始终以生产代码的稳定性和质量为核心。严禁为了通过测试而进行过度设计，确保代码逻辑简洁、高效
2. 测试同步与验证：每次修改代码时，必须同步更新对应的自动化测试。修改完成后，必须运行 `npm test` 确保所有测试用例 100% 通过
3. 自动化错误修复：若 `npm test` 未通过，必须自动分析原因并持续修复，直到测试完全通过为止
4. 规范化提交 (Conventional Commits)：使用英文 Conventional Commits 规范（如 `feat:`, `fix:`, `docs:` 等）提交代码，确保提交信息清晰、专业
5. 配置同步更新：当代码接口、API 行为或功能逻辑发生改变后，必须及时更新 `manifest.json` 以保持一致
6. 在执行 standard-version 之前，先运行 npm install --package-lock-only 以确保 package-lock.json 的版本号与代码库状态保持同步，防止发版后出现版本不一致的情况
7. 当遇到复杂任务时，自动分解为更小的可执行步骤并直接输出。

# 复杂脚本执行规范

- 禁止行内代码：凡是超过 2 行或涉及复杂逻辑的 Node.js 指令，严禁使用 node -e。
- 临时文件流：
  1. 创建：将逻辑写入临时文件 scripts/tmp_test.js。
  2. 运行：通过 node 命令执行该文件。
  3. 清理：任务完成后，必须立即删除该临时文件。
- 目的：减少频繁的终端审批请求，确保代码可读且易于调试。

# 自动化测试编写规则

## 1. Execution Constraints (执行约束 - 确保确定性)

- **IO Isolation:** 单元测试严禁任何真实 IO（DB, HTTP, FS, Redis, Queue）。所有外部依赖必须 Mock。
- **No Networking:** 禁止在测试生命周期（test/before/after）中启动 Server 或监听真实物理端口。
- **Time Control:** 禁止使用真实系统时间（`Date.now`, `setTimeout`）。必须使用时钟模拟器（如 `useFakeTimers`）。
- **Performance Budget:** * 单个 Test Case 执行时间 $\le 30\text{ms}$。
  - 单个 Test File 执行时间 $\le 300\text{ms}$。
- **No Side Effects:** * 禁止读取真实 `process.env`，必须通过依赖注入或显式 Mock。
  - 禁止 `console.log`，调试信息应体现为失败断言。
  - 测试结束后必须零残留（无 Open Handles, Timers, Sockets）。
- **Determinism:** 禁止使用随机数。必须 Mock `Math.random` 或指定随机种子。

## 2. Implementation Patterns (实现模式 - 确保稳定性)

- **Parallel Readiness:** 每个用例必须 100% 可并行化。严禁依赖共享的全局状态。
- **Minimal Setup:** 禁止在 `beforeAll` 做全局初始化。优先使用 `per-test` 的局部构造，确保环境干净。
- **Async Handling:** * 所有 Promise 必须被 `await`，严禁 Fire-and-forget。
  - 禁止在异步测试中使用 `done()` 回调，统一使用 `async/await`。
- **Explicit Mocking:** 所有 Mock 必须在 Test 内部或紧邻的 Scope 显式声明。禁止使用全局隐式 Auto-mock。
- **Explicit Waits:** 严禁 `sleep(ms)`。必须使用“显式等待”机制（如 `waitUntil(condition)`），以适应波动的执行环境。
- **Data Strategy:** * **独立构造：** 禁止调用生产环境的 Utility 类构造测试数据，防止“BUG 传递”。
  - **即用即毁：** 使用 Ephemeral Data（如随机 UUID），测试结束立即清理。

## 3. Design Philosophy (设计哲学 - 确保质量)

- **Verification of State (State over Process):** * **验证结果而非过程：** 聚焦于输入 $A$ 产生输出 $B$ 或状态 $C$。
  - **禁止验证内部细节：** 不要断言私有方法调用、循环次数或具体数据结构（如 `ArrayList` vs `LinkedList`）。
- **Anti-Fragility (防碎性):** * **硬编码预期值：** 断言的预期结果应是硬编码的常量。禁止通过调用生产逻辑来计算预期值（避免 `assert result == production_calc(input)`）。
  - **三层架构：** 遵循 `DSL层 (Business Context) -> 逻辑抽象层 (Action/Tasks) -> 驱动层 (Protocol/Driver)`。
- **Assertion Intent:** 使用语义化断言（如 `assertThat(user).isActive()`）而非原始逻辑比较（如 `assert user.status == 1`）。
- **Snapshot Policy:** Snapshot 仅限用于 UI 结构或大段不可变输出验证，严禁用于验证核心业务逻辑。

**严格执行上述规则。确保正确性并达成性能指标，优先于精简表达。**